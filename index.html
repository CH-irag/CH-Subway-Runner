<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>CH Subway Runner</title>
  <style>
    body { 
        margin:0; overflow:hidden; 
        font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
        background-color: #000;
        /* CRITICAL FIX: Stops the browser from delaying touches */
        touch-action: none; 
        -webkit-touch-callout: none;
        user-select: none;
    }

    /* UI Styling */
    #menu, #gameover {
      position:absolute; inset:0;
      display:flex; flex-direction:column;
      justify-content:center; align-items:center;
      background: radial-gradient(circle, rgba(255,200,220,0.95) 0%, rgba(100,50,150,0.95) 100%);
      z-index:10;
      color: white;
      text-shadow: 2px 2px 0 #000;
    }
    #gameover { display:none; }

    h1 { font-size: 50px; font-weight: 900; transform: skew(-10deg); color: #ffeb3b; -webkit-text-stroke: 2px #d32f2f; margin-bottom: 20px; text-align: center; }
    
    button {
      padding:15px 40px;
      border:none; border-radius:30px;
      font-size:24px; font-weight: bold;
      background: linear-gradient(#42a5f5, #1e88e5);
      color: white;
      cursor: pointer;
      box-shadow: 0 6px 0 #0d47a1, 0 10px 10px rgba(0,0,0,0.3);
      transition: transform 0.1s;
    }
    button:active { transform: translateY(4px); box-shadow: 0 2px 0 #0d47a1; }

    /* Updated Score Box to fit Highscore */
    #scoreContainer {
      position:absolute; top:20px; right:20px; left: auto;
      text-align: right;
      z-index:5;
      background: rgba(0,0,0,0.4);
      padding: 10px 20px;
      border-radius: 20px;
      border: 3px solid white;
      min-width: 120px;
    }
    #score {
      font-size:28px; font-weight: 800; color: #ffeb3b;
      text-shadow: 2px 2px 0 #000;
    }
    #highScoreDisplay {
      font-size:16px; font-weight: 700; color: #ffffff;
      margin-top: -5px;
    }

    #countdown {
      position:absolute; inset:0;
      display:none; justify-content:center; align-items:center;
      font-size:120px; font-weight:900;
      color:#ffeb3b; -webkit-text-stroke: 4px #d32f2f;
      text-shadow: 5px 5px 0px #000;
      z-index:9;
    }
    
    p { font-size: 18px; color: white; font-weight: bold; margin-top: 20px;}
  </style>
</head>
<body>

<div id="menu">
  <h1>üöÑ CH SUBWAY RUNNER</h1>
  <button onclick="startGame()">TAP TO PLAY</button>
  <p>‚¨ÖÔ∏è‚û°Ô∏è Move ‚Ä¢ ‚¨ÜÔ∏è Jump ‚Ä¢ ‚¨áÔ∏è Roll</p>
</div>

<div id="countdown"></div>

<div id="gameover">
  <h1 style="color:#ff5252">CRASHED!</h1>
  <h2 id="finalScore"></h2>
  <h3 id="finalBest" style="margin-bottom:20px; color:#ffeb3b"></h3>
  <button onclick="location.reload()">PLAY AGAIN</button>
</div>

<div id="scoreContainer">
  <div id="score">0</div>
  <div id="highScoreDisplay">HI: <span id="hiScoreVal">0</span></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
let scene, camera, renderer;
let player;

/* ===== OPTIMIZATION: REUSABLE OBJECTS ===== */
// Creating these once prevents the "Lag Spikes" seen in your video
const trainGeometry = new THREE.BoxGeometry(2.4, 3, 10);
const barrierGeometry = new THREE.BoxGeometry(2.2, 1.2, 0.5);
const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 2.5, 8);
const lightGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.1);

// Pre-create materials
const matBlue = new THREE.MeshLambertMaterial({color: 0x1565c0}); 
const matRed = new THREE.MeshLambertMaterial({color: 0xc62828});
const matBarrier = new THREE.MeshLambertMaterial({color: 0x8d6e63});
const matWheel = new THREE.MeshLambertMaterial({color: 0x111111});
const matLight = new THREE.MeshBasicMaterial({color: 0xffff00});

// Rotate wheel geometry once globally
wheelGeometry.rotateZ(Math.PI/2);


/* ===== AUDIO SYSTEM ===== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let musicScheduler = null;
let isPlayingMusic = false;
let baseInterval = 220; 

const melody = [
  523, 587, 659, 523, 494, 440, 494, 523,
  659, 587, 523, 494, 440, 392, 440, 494,
  784, 659, 587, 523, 494, 440, 392, 440,
  262, 294, 330, 262, 247, 220, 247, 262
];
const bassNotes = [131, 147, 165, 131, 123, 110, 123, 131];

function playFunNote(freq, duration=180, volume=0.15, type="sawtooth"){
  if(audioCtx.state === 'suspended') audioCtx.resume();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.frequency.value = freq;
  osc.type = type;
  gain.gain.setValueAtTime(0, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration/1000);
  const filter = audioCtx.createBiquadFilter();
  filter.type = "lowpass";
  filter.frequency.value = 1200;
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration/1000);
}

function playBass(freq, duration=250, volume=0.12){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.frequency.value = freq;
  osc.type = "triangle";
  gain.gain.setValueAtTime(volume*0.8, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration/1000);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration/1000);
}

function getCurrentMusicInterval(){
  const speedFactor = worldSpeed / maxSpeed;
  const musicSpeedup = speedFactor * 80;
  return Math.max(baseInterval - musicSpeedup, 120);
}

function startFunMusic(){
  if(isPlayingMusic) return;
  isPlayingMusic = true;
  let melodyIndex = 0;
  let bassIndex = 0;
  function musicLoop(){
    if(!isPlayingMusic) return;
    const note = melody[melodyIndex % melody.length];
    playFunNote(note, 200);
    if(melodyIndex % 4 === 0){
      const bass = bassNotes[bassIndex % bassNotes.length];
      playBass(bass, 300);
    }
    melodyIndex++;
    if(melodyIndex % 8 === 0) bassIndex++;
    const nextInterval = getCurrentMusicInterval();
    musicScheduler = setTimeout(musicLoop, nextInterval);
  }
  musicLoop();
}

function stopFunMusic(){
  isPlayingMusic = false;
  if(musicScheduler){ clearTimeout(musicScheduler); musicScheduler = null; }
}

function playJumpSound(){ playFunNote(659, 100, 0.25, "square"); }
function playHitSound(){ playFunNote(196, 300, 0.3, "sawtooth"); }

/* ===== GAME VARIABLES ===== */
const lanes = [-2.5, 0, 2.5];
let currentLane = 1;

let worldSpeed = 0.45;
const maxSpeed = 1.8;

let gravity = -0.022; 
let velY = 0;
let jumping = false;
let fastFall = false;

let obstacles = [];
let roadPieces = [];
let buildings = [];

let score = 0;
let highScore = Number(localStorage.getItem("runnerHighScore")) || 0;
document.getElementById("hiScoreVal").innerText = highScore;

let started=false, paused=false, countingDown=false;

/* ================= TEXTURES ================= */
function createTrackTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#8d6e63'; 
    ctx.fillRect(0,0,512,512);
    // Optimized: Reduced particle count slightly for texture generation speed
    for(let i=0; i<400; i++) {
        ctx.fillStyle = Math.random() > 0.5 ? '#6d4c41' : '#a1887f';
        ctx.fillRect(Math.random()*512, Math.random()*512, 4, 4);
    }
    const centers = [106, 256, 406]; 
    ctx.fillStyle = '#4e342e';
    for(let y=0; y<512; y+=40) {
        centers.forEach(x => { ctx.fillRect(x - 50, y, 100, 15); });
    }
    ctx.fillStyle = '#b0bec5'; 
    centers.forEach(x => {
        ctx.fillRect(x - 35, 0, 8, 512);
        ctx.fillRect(x + 27, 0, 8, 512);
    });
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
    tex.minFilter = THREE.LinearFilter;
    return tex;
}
const trackTexture = createTrackTexture();

/* ================= INIT ================= */
function startGame(){
  if(audioCtx.state === 'suspended') audioCtx.resume();
  document.getElementById("menu").style.display="none";
  countingDown=true;
  const cd=document.getElementById("countdown");
  cd.style.display="flex";
  let c=3; cd.innerText=c;
  let t=setInterval(()=>{
    c--;
    if(c>0) cd.innerText=c;
    else if(c==0) cd.innerText="GO!";
    else{
      clearInterval(t); cd.style.display="none"; countingDown=false; started=true;
      startFunMusic();
    }
  },700);
}

function gameOver(){
  started = false;
  playHitSound();
  stopFunMusic();
  document.getElementById("gameover").style.display="flex";
  document.getElementById("finalScore").innerText = "SCORE: " + score;
  document.getElementById("finalBest").innerText = "BEST: " + highScore;
}

init();
animate();

function init(){
  scene = new THREE.Scene();
  const skyColor = 0xffc0cb; 
  scene.background = new THREE.Color(skyColor);
  scene.fog = new THREE.Fog(skyColor, 20, 90);

  camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 5, 11);
  camera.rotation.x = -0.2;

  // OPTIMIZATION: High Performance Mode
  renderer = new THREE.WebGLRenderer({antialias:true, powerPreference: "high-performance"});
  
  // OPTIMIZATION: Cap Pixel Ratio to 2 (Fixes lag on High DPI phones)
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer, nicer shadows
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  document.body.appendChild(renderer.domElement);

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffb6c1, 0.8);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffd54f, 1.2); 
  dirLight.position.set(20, 50, 20);
  dirLight.castShadow = true;
  // Optimized Shadow Camera
  dirLight.shadow.mapSize.width = 1024;
  dirLight.shadow.mapSize.height = 1024;
  dirLight.shadow.camera.left = -20;
  dirLight.shadow.camera.right = 20;
  dirLight.shadow.camera.top = 20;
  dirLight.shadow.camera.bottom = -20;
  scene.add(dirLight);

  createPlayer();
  createRoad();
  createBuildings();

  setInterval(spawnObstacle, 500);
  setupControls();
  
  // Handle resize to prevent distortion
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function createPlayer(){
  const group = new THREE.Group();
  
  // Body
  const bodyGeo = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
  const bodyMat = new THREE.MeshToonMaterial({color: 0x00e676}); 
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.5;
  
  // Head
  const headGeo = new THREE.SphereGeometry(0.4, 16, 16);
  const headMat = new THREE.MeshToonMaterial({color: 0xffcc80});
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.4;

  // Cap
  const capGeo = new THREE.CylinderGeometry(0.42, 0.42, 0.2, 16);
  const capMat = new THREE.MeshStandardMaterial({color: 0xff4081}); 
  const cap = new THREE.Mesh(capGeo, capMat);
  cap.position.y = 1.6;
  cap.rotation.x = -0.1;
  
  group.add(body); group.add(head); group.add(cap);
  group.position.set(0,1.5,0);
  
  const shadowGeo = new THREE.CircleGeometry(0.6, 16);
  const shadowMat = new THREE.MeshBasicMaterial({color:0x000000, opacity:0.3, transparent:true});
  const shadow = new THREE.Mesh(shadowGeo, shadowMat);
  shadow.rotation.x = -Math.PI/2;
  shadow.position.y = -1.45; 
  group.add(shadow);

  player = group;
  scene.add(player);
}

function createRoad(){
  const groundGeo = new THREE.PlaneGeometry(200, 300);
  const groundMat = new THREE.MeshStandardMaterial({color: 0xeecfa1});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.1;
  ground.position.z = -100;
  scene.add(ground);

  // Reusable geometry for road segments
  const roadGeo = new THREE.PlaneGeometry(12, 50);
  const roadMat = new THREE.MeshStandardMaterial({ map: trackTexture });

  for(let i=0;i<8;i++){
    const piece = new THREE.Mesh(roadGeo, roadMat);
    piece.rotation.x = -Math.PI/2;
    piece.position.z = -i*50;
    piece.receiveShadow = true;
    scene.add(piece);
    roadPieces.push(piece);
  }
}

function createBuildings(){
  const palette = [0x4fc3f7, 0xff8a65, 0xba68c8, 0xffb74d, 0x81c784];
  const materials = palette.map(c => new THREE.MeshToonMaterial({ color: c }));
  const geom = new THREE.BoxGeometry(1,1,1); // Base geometry to be scaled

  for(let i=0;i<50;i++){
    const h = Math.random()*10 + 10;
    const w = Math.random()*3 + 3;
    const mat = materials[Math.floor(Math.random()*materials.length)];
    
    // Create mesh but re-use materials
    const b = new THREE.Mesh(geom, mat);
    b.scale.set(w, h, w); // Scale instead of new Geometry
    
    const xPos = Math.random()>0.5 ? (9 + Math.random()*5) : (-9 - Math.random()*5);
    b.position.set(xPos, h/2, -i*10);
    b.castShadow = true;
    scene.add(b);
    buildings.push(b);
  }
}

function setupControls(){
  let sx=0, sy=0;
  window.addEventListener("touchstart",e=>{ sx=e.touches[0].clientX; sy=e.touches[0].clientY; }, {passive: false});
  window.addEventListener("touchend",e=>{
    if(!started) return;
    let dx=e.changedTouches[0].clientX-sx;
    let dy=e.changedTouches[0].clientY-sy;
    if(Math.abs(dx)>Math.abs(dy)){
      dx>30?currentLane=Math.min(2,currentLane+1): dx<-30&&(currentLane=Math.max(0,currentLane-1));
    } else {
      if(dy<-30){ jump(); playJumpSound(); }
      if(dy>30) fastFall=true;
    }
  }, {passive: false});
  window.addEventListener("keydown", e=>{
      if(!started) return;
      if(e.key==="ArrowLeft") currentLane=Math.max(0,currentLane-1);
      if(e.key==="ArrowRight") currentLane=Math.min(2,currentLane+1);
      if(e.key==="ArrowUp") { jump(); playJumpSound(); }
      if(e.key==="ArrowDown") fastFall=true;
  });
}

function jump(){
  if(!jumping){ 
    velY=0.48; 
    jumping=true; 
  }
}

function spawnObstacle(){
  if(!started) return;
  const type = Math.random(); 
  const isTrain = type > 0.5;
  let obs;
  let yPos;

  // OPTIMIZATION: Reusing Global Geometries & Materials
  // This removes the "Garbage Collection" stutter
  if(isTrain) {
      const isBlue = Math.random() > 0.5;
      obs = new THREE.Mesh(trainGeometry, isBlue ? matBlue : matRed);
      yPos = 1.5; 
  } else {
      obs = new THREE.Mesh(barrierGeometry, matBarrier);
      yPos = 0.6;
  }

  const r = Math.random();
  let pattern = [0,0,0];
  if(r < 0.35) pattern[Math.floor(Math.random()*3)] = 1;
  else if(r < 0.6) { pattern[currentLane] = 1; pattern[(currentLane+1)%3] = 1; }
  else pattern[Math.floor(Math.random()*3)] = 1;

  pattern.forEach((v,i)=>{
    if(v){
      // Clone if we need multiple in one spawn (rare but safe here since geometry is shared)
      const instance = obs.clone(); 
      instance.position.set(lanes[i], yPos, -150);
      instance.castShadow = true;
      instance.isTrain = isTrain; 
      scene.add(instance);
      obstacles.push(instance);
      
      if(isTrain){
          // Add details using shared geometries
          const l1 = new THREE.Mesh(lightGeometry, matLight);
          l1.position.set(0.6,-1,5);
          const l2 = l1.clone(); l2.position.set(-0.6,-1,5);
          instance.add(l1); instance.add(l2);

          const w1 = new THREE.Mesh(wheelGeometry, matWheel); w1.position.set(0, -1.5, 3);
          const w2 = w1.clone(); w2.position.set(0, -1.5, -3);
          instance.add(w1); instance.add(w2);
      }
    }
  });
}

function animate(){
  requestAnimationFrame(animate);

  if(!started||paused||countingDown){
    renderer.render(scene,camera);
    return;
  }

  player.position.x += (lanes[currentLane]-player.position.x)*0.2;
  player.rotation.z = (lanes[currentLane]-player.position.x) * -0.1;

  let groundY = 1.5; 
  
  obstacles.forEach(o=>{
    let dx = Math.abs(o.position.x - player.position.x);
    let dz = Math.abs(o.position.z - player.position.z); 

    if(dx < 0.7) {
        if(o.isTrain) {
            if(dz < 5.2) {
                if(player.position.y >= 3.8) {
                    groundY = 4.5; 
                } else {
                    gameOver();
                }
            }
        } else {
            if(dz < 0.8) {
                if(player.position.y > 2.2) {
                } else {
                    gameOver();
                }
            }
        }
    }
  });

  velY += gravity;
  if(fastFall) velY -= 0.08;

  player.position.y += velY;

  if(player.position.y <= groundY){
    player.position.y = groundY;
    velY = 0;
    jumping = false;
    fastFall = false;
  }

  [...roadPieces,...buildings,...obstacles].forEach(o=>o.position.z+=worldSpeed);

  roadPieces.forEach(p=>{ if(p.position.z>50) p.position.z -= 400; });
  buildings.forEach(b=>{ 
      if(b.position.z>20) {
          b.position.z -= 500;
          b.position.x = Math.random()>0.5 ? (9 + Math.random()*5) : (-9 - Math.random()*5);
      }
  });

  if(obstacles.length > 0 && obstacles[0].position.z > 20){
      scene.remove(obstacles[0]);
      obstacles.shift();
  }

  camera.position.x += (player.position.x * 0.5 - camera.position.x) * 0.1;
  camera.position.y = 5 + (player.position.y - 1.5) * 0.5; 

  if(worldSpeed<maxSpeed) worldSpeed+=0.0003;

  score++;
  if(score > highScore){ 
    highScore = score; 
    localStorage.setItem("runnerHighScore", highScore); 
    document.getElementById("hiScoreVal").innerText = highScore;
  }
  
  document.getElementById("score").innerText = score;
  renderer.render(scene,camera);
}
</script>
</body>
</html>